<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Aptxx</title><link>https://aptxx.com/posts/</link><description>Recent content in Posts on Aptxx</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 01 Oct 2022 20:23:15 +0800</lastBuildDate><atom:link href="https://aptxx.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Recommended Go Packages</title><link>https://aptxx.com/posts/recommended-go-packages/</link><pubDate>Sat, 01 Oct 2022 20:23:15 +0800</pubDate><guid>https://aptxx.com/posts/recommended-go-packages/</guid><description>以下是推荐的软件包，它们在生产环境下表现不错
Package Comment Repository fasthttp 高性能 HTTP 服务器和客户端 https://github.com/valyala/fasthttp fasttemplate 高性能字符串替换 https://github.com/valyala/fasttemplate fastjson 高性能 JSON 解析 https://github.com/valyala/fastjson qucktemplate 高性能序列化到 HTML/JSON/XML https://github.com/valyala/quicktemplate tableflip 热升级 https://github.com/cloudflare/tableflip UUID Google 的项目 https://github.com/google/uuid structure 推荐的文件目录结构 https://github.com/golang-standards/project-layout godotenv 环境变量 https://github.com/joho/godotenv sqlx 数据库工具 https://github.com/jmoiron/sqlx</description></item><item><title>Golang Rand Concurrency Safe</title><link>https://aptxx.com/posts/golang-rand-concurrency-safe/</link><pubDate>Wed, 11 Nov 2020 00:38:46 +0800</pubDate><guid>https://aptxx.com/posts/golang-rand-concurrency-safe/</guid><description>Golang 提供标准随机包 math/rand，随机包默认会创建一个全局的对象，从源码上可以看到使用了 lockedSource 这个源，并且是基于 1 创建的 Source，也就是说每次初始化都是固定的结果，这一点和 C 一样。
var globalRand = New(&amp;amp;lockedSource{src: NewSource(1).(*rngSource)}) // Type assert that globalRand&amp;#39;s source is a lockedSource whose src is a *rngSource. var _ *rngSource = globalRand.src.(*lockedSource).src 在项目中为了增加随机性，比较常见的做法是每次程序启动时都把全局的随机对象重新设置一下，比如用当前时间作为随机种子，这一切看起来都非常美好，直到某个比较有想法的包出现。
import ( &amp;#34;math/rand&amp;#34; &amp;#34;time&amp;#34; ) func init() { rand.Seed(time.Now().UnixNano()) } 现在试想一下需要开发一个独立的包，基于某些原因它需要使用随机数，自然而然的想到 math/rand 包，但是基于解耦和随机安全的考虑，肯定是不能使用系统自带的全局随机对象，因为无法保证它有没有被好好设置，也不太好自己主动去设置。所以会使用系统的包重新创建随机对象，自然而然的有了如下操作。
r := rand.New(NewSource(time.Now().UnixNano())) 然而这里有坑，虽然标准的随机对象是并发安全的，但是标准包的 NewSource 创建的 Source 并不是并发安全的，如果你仔细阅读，就会发现注释以一个不起眼的方式告知着。
// NewSource returns a new pseudo-random Source seeded with the given value. // Unlike the default Source used by top-level functions, this source is not // safe for concurrent use by multiple goroutines.</description></item></channel></rss>